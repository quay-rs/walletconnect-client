use super::{
    super::domain::{SubscriptionId, Topic},
    GenericError, Params, RequestPayload, ValidationError,
};
use serde::{Deserialize, Serialize};
/// Data structure representing subscribe request params.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Subscribe {
    /// The topic to subscribe to.
    pub topic: Topic,
}

impl RequestPayload for Subscribe {
    type Error = GenericError;
    type Response = SubscriptionId;

    fn validate(&self) -> Result<(), ValidationError> {
        self.topic.decode().map_err(ValidationError::TopicDecoding)?;

        Ok(())
    }

    fn into_params(self) -> Params {
        Params::Subscribe(self)
    }
}

/// Data structure representing unsubscribe request params.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct Unsubscribe {
    /// The topic to unsubscribe from.
    pub topic: Topic,

    /// The id of the subscription to unsubscribe from.
    #[serde(rename = "id")]
    pub subscription_id: SubscriptionId,
}

impl RequestPayload for Unsubscribe {
    type Error = GenericError;
    type Response = bool;

    fn validate(&self) -> Result<(), ValidationError> {
        self.topic.decode().map_err(ValidationError::TopicDecoding)?;

        // FIXME: Subscription ID validation is currently disabled, since SDKs do not
        // use the actual IDs generated by the relay, and instead send some randomized
        // values. We should either fix SDKs to ensure they properly utilize the IDs, or
        // just remove it from the payload.

        // self.subscription_id
        //     .decode()
        //     .map_err(ValidationError::SubscriptionIdDecoding)?;

        Ok(())
    }

    fn into_params(self) -> Params {
        Params::Unsubscribe(self)
    }
}
